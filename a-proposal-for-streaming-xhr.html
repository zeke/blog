<!DOCTYPE html> 
<html> 
<head> 
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link rel="alternate" type="application/rss+xml" title="Max Ogden Blogotronz (RSS 2.0)" href="http://maxogden.com/rss.xml">
  <title>Max Ogden Blogotronz</title> 
  
  <link href="styles/styles.css" media="screen" rel="stylesheet" type="text/css">
  <link href="styles/rainbow.github.css" media="screen" rel="stylesheet" type="text/css">

  <!-- libraries --> 
  <script src="script/jquery-1.6.1.min.js"></script>
  <script src="script/underscore.js"></script>
  <script src="script/d3.min.js"></script>
  <script src="script/voronoi.min.js"></script>
  <script src="script/rainbow.min.js"></script>
  <script src="script/rainbow.generic.js"></script>
  <script src="script/rainbow.javascript.js"></script>
  <script src="script/rainbow.css.js"></script>
  <script src="script/helpers.js"></script>
  
  <script src="script/application.js"></script>

</head>
<body> 
  <div id="container">
    <div class="header">
      <div class="title">Max Ogden | <a href="http://tantek.com/2010/281/b1/what-is-the-open-web">Open Web</a> developer</div>
      <div class="subtitle"></div>
      <!-- THANKS, MICHAEL BOSTOCK! YOU RULE -->
      <div id="voronoi">
      </div>
      <div class="channel"></div>
      <div id="navigation">
        <div class="toggle home">
          <div class="navitem">
            <a href="index.html">blog</a>
          </div>
        </div>
        <div class="toggle home">
          <div class="navitem">
            <a href="projects.html">projects</a>
          </div>
        </div>
        <div class="toggle home">
          <div class="navitem">
            <a href="videos.html">media</a>
          </div>
        </div>
        <div class="toggle home">
          <div class="navitem">
            <a href="contact.html">contact</a>
          </div>
        </div>
      </div>
    </div>
    
    <div id="wrapper">
      <div id="browser">
        <div id="documents"><a class="load-document" href="bringing-minecraft-style-games-to-the-open-web.html">
  <div class="document" id="bringing-minecraft-style-games-to-the-open-web">
    <div class="published" data-published="2013-01-25T20:48:11.493Z">January 2013</div>
    <div class="title">Bringing Minecraft-style games to the Open Web</div>
    <div class="teaser">A status report from the one month old voxel.js project</div>
  </div>
</a>

<a class="load-document" href="a-proposal-for-streaming-xhr.html">
  <div class="document active" id="a-proposal-for-streaming-xhr">
    <div class="published" data-published="2012-11-20T20:48:11.493Z">November 2012</div>
    <div class="title">A Proposal For Streaming XHR</div>
    <div class="teaser">XHR2 isn't stream friendly. Lets explore why and propose a solution!</div>
  </div>
</a>

<a class="load-document" href="scraping-with-node.html">
  <div class="document" id="scraping-with-node">
    <div class="published" data-published="2012-10-24T20:48:11.493Z">October 2012</div>
    <div class="title">Scraping With Node</div>
    <div class="teaser">Useful modules and a tutorial on how to parse HTML with node.js</div>
  </div>
</a>

<a class="load-document" href="building-webview-applications.html">
  <div class="document" id="building-webview-applications">
    <div class="published" data-published="2012-10-15T20:48:11.493Z">October 2012</div>
    <div class="title">Building WebView Applications</div>
    <div class="teaser">Things I learned while building @gather</div>
  </div>
</a>

<a class="load-document" href="fast-webview-applications.html">
  <div class="document" id="fast-webview-applications">
    <div class="published" data-published="2012-05-31T20:48:11.493Z">May 2012</div>
    <div class="title">Fast WebView Applications</div>
    <div class="teaser">How to make web apps feel fast and responsive</div>
  </div>
</a>

<a class="load-document" href="node-streams.html">
  <div class="document" id="node-streams">
    <div class="published" data-published="2012-04-17T23:52:20.241Z">April 2012</div>
    <div class="title">Node Streams: How do they work?</div>
    <div class="teaser">Description of and notes on the node.js Stream API</div>
  </div>
</a>

<a class="load-document" href="replicating-large-datasets-into-html5.html">
  <div class="document" id="replicating-large-datasets-into-html5">
    <div class="published" data-published="2012-04-14T06:32:16.787Z">April 2012</div>
    <div class="title">Replicating large datasets into HTML5</div>
    <div class="teaser">Typed arrays, streaming json and IndexedDB!</div>
  </div>
</a>

<a class="load-document" href="open211.html">
  <div class="document" id="open211">
    <div class="published" data-published="2012-01-30T01:57:20.310Z">January 2012</div>
    <div class="title">Open211</div>
    <div class="teaser">An open source directory of social programs and services</div>
  </div>
</a>

<a class="load-document" href="gut-hosted-open-data-filets.html">
  <div class="document" id="gut-hosted-open-data-filets">
    <div class="published" data-published="2011-12-02T20:36:31.424Z">December 2011</div>
    <div class="title">Gut: Hosted Open Data Filet Knives</div>
    <div class="teaser">HTTP Unix pipes for Open Data</div>
  </div>
</a>

<a class="load-document" href="mobile-crowdsourcing-interfaces.html">
  <div class="document" id="mobile-crowdsourcing-interfaces">
    <div class="published" data-published="2011-07-30T17:20:49.949Z">July 2011</div>
    <div class="title">Mobile Crowdsourcing Interfaces</div>
    <div class="teaser">Some experiments in collecting images + location from mobile devices</div>
  </div>
</a>

<a class="load-document" href="little-coders.html">
  <div class="document" id="little-coders">
    <div class="published" data-published="2011-07-17T02:56:48.555Z">July 2011</div>
    <div class="title">Little Coders</div>
    <div class="teaser">Elementary school programming</div>
  </div>
</a></div>
      </div>
      <div id="document"><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta http-equiv="Content-Style-Type" content="text/css">
    <meta name="generator" content="pandoc">
    <meta name="author" content="Max Ogden">
    <title>Streaming XHR</title>
  </head>
  
  <body>
    <div id="header">
      <h1 class="title">Streaming XHR</h1>
      <h2 class="author">Max Ogden</h2>
    </div>
    <p>XHR2 isn't stream friendly. Lets explore why and look at what the future holds!</p>
    <p>Note: While writing this I found out about the new <a href="http://dvcs.w3.org/hg/streams-api/raw-file/tip/Overview.htm">Stream</a> API. I'm currently rewriting this article to reflect that.</p>
    <p><a href="http://www.html5rocks.com/en/tutorials/file/xhr2/">XHR2</a> (XHR is short for XMLHTTPRequest and is the HTTP client in AJAX) does some cool stuff. You can get binary response data, either read-only in a <a href="https://developer.mozilla.org/en-US/docs/DOM/Blob">Blob</a> or mutable in an <a href="https://developer.mozilla.org/en-US/docs/JavaScript_typed_arrays/ArrayBuffer#ArrayBuffer()">Array Buffer</a> (which you can turn into one of the many flavors of <a href="https://developer.mozilla.org/en-US/docs/JavaScript_typed_arrays">Typed Arrays</a>). Binary data in JavaScript pushes the boundaries of the web by enabling rich multimedia experiences (like those demonstrated in <a href="http://www.youtube.com/watch?v=PN8Eg1K9xjE">this mind-blowing talk</a> on the Web Audio API by <a href="twitter.com/stuartmemo">@stuartmemo</a>).</p>
    <p>There is one fundamental problem with the current XHR specification (and implementations) which is that they aren't designed for real-time streaming, but with a few tweaks I believe they can enable a much better web experience.
      
    <p>Here is an example of trying to wrap XHR in the <a href="https://github.com/substack/stream-handbook">node.js Stream API</a>. The important part of the following code is the <code>write</code> function which takes the Array Buffer that XHR returns, turns it into a Typed Array and then emits each new chunk of binary data each time that xhr.readyState 3 is fired.</p>
<pre><code data-language="javascript">var stream = require('stream')
var util = require('util')

function XHRStream(xhr) {
  stream.Stream.call(this)
  this.xhr = xhr
  this.offset = 0
  xhr.onreadystatechange = this.handle.bind(this)
  xhr.send(null)
}

// copy the Stream methods to this prototype
util.inherits(XHRStream, stream.Stream)

XHRStream.prototype.handle = function () {
  // readyState 3 will be fired many times during a large download
  if (this.xhr.readyState === 3) this.write()
  if (this.xhr.readyState === 4) this.emit('end')
}

XHRStream.prototype.write = function () {
  if (!this.responseArray) this.responseArray = new Int8Array(this.xhr.response)
  if (this.responseArray.byteLength > this.offset) {
    this.emit('data', this.responseArray.slice(this.offset))
    this.offset = this.responseArray.byteLength
  }
}

module.exports = XHRStream
</code></pre>
    <p>Fundamentally what node Streams (and the above code) do is take a huge response that may take a loooooong time to complete (like downloading a Blu-ray DVD) and splits the response up into chunks. This is a beautiful pattern due to its simplicity. The programmer can decide if they want to combine the chunks and store them in a file or database OR if they want to process the chunks one at a time immediately and then throw the chunks away so that the JavaScript VM can clean the chunks up and free up the memory they were using. The <code>xhr.response</code> (<code>xhr.responseText</code> when getting non-binary responseTypes) in an XHR request is a single JavaScript object that just grows and grows and grows so if you are downloading a 5GB file you will have a 5GB JavaScript object in memory at the end of the request. The "node way" would be to have hundreds of small objects that each contain a contiguous chunk of the file that get emitted as soon as the client receives the data from the network.</p>
    <p>The XHRStream prototype lets you write code that looks like this:</p>
<pre><code data-language="javascript">var xhr = new XMLHttpRequest()
xhr.responseType = 'arraybuffer'
xhr.open("GET", "http://bigdata.com/hugefile.zip", true)
var response = new XHRStream(xhr)

// 'data' events will happen each time a new chunk gets to the browser
response.on('data', function(chunk) {
  // chunk size in this case is determined by TCP and will
  // probably be in the range of 10s or 100s of kilobytes
})
</code></pre>
    <p>Unfortunately this isn't possible with the current XHR implementation for two reasons. The first is that <code>xhr.response</code> is essentially one big buffer that keeps growing linearly as the response data comes in which means it can't get garbage collected. This just means you can't download files with XHR that are larger than the amount of RAM in your machine which isn't a total deal breaker for streaming data. The other reason is that currently the XHR spec prevents access to binary response data before the request has completed. Here is a simplified excerpt from the <a href="http://www.w3.org/TR/XMLHttpRequest/#the-response-attribute">XMLHTTPRequest specification on w3.org</a> (thanks to <a href="http://twitter.com/tobie">@tobie</a> for assisting me in navigating the web standards world here):</p>
    <pre><code>If responseType is "text"
  If the state is not LOADING or DONE, return empty string and terminate these steps
  Otherwise return the text response entity body.
Otherwise (for all other types of responseTypes such as 'arraybuffer' or 'blob')
  If the state is not DONE, return null and terminate these steps.
    </code></pre>
    <p>Here is <a href="http://lists.whatwg.org/pipermail/whatwg-whatwg.org/2011-January/029992.html">a discussion from the whatwg mailing list</a> on this topic that contains this particularly insightful comment:</p>
    <pre><code>Hmm! And I guess it's very difficult to create a abstract in/out 
interface that can handle any protocol/stream.
Although an abstract in/out would be ideal as that would let new 
protocols to be supported without needing to rewrite anything at the 
higher level.

-- 
Roger "Rescator" Hågensen.
    </code></pre>
    <p>I totally agree! It turns out that the node Stream API, which is the core I/O abstraction in Node.js (which is a tool for I/O) is essentially an abstract in/out interface that can handle any protocol/stream that also happens to be written in JavaScript.</p>
    <p>It should be noted that websockets now support transporting binary data but the websocket spec still <a href="https://github.com/maxogden/websocket-stream/issues/1">isn't perfect</a> for streaming and the overwhelming majority of APIs are HTTP.</p>
    <p>So, to any standards people or browser implementers reading this: please please please take some notes from Node.js and change the spec to allow for truly streaming data over XMLHTTPRequest.</p>
</p></body>

</html></div>
    </div>
  </div>  
  
  <script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-24933665-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

  </script>
</body> 
</html>
